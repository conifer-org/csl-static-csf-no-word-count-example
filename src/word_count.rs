use std::any::Any;
use std::collections::HashMap;
use std::ops::Deref;
use std::slice;
use std::str;
use serde::{Serialize, Deserialize};

use postcard::{from_bytes, to_allocvec};

#[csl::atom(name = "word_count_main")]
const INPUT_TEXT: &str = include_str!("static/demo.txt");

/// Let's enjoy doing some decorations
/// THis is App-dev defined
#[csl::atom(name = "word_count_main")]
#[csl::boot_electron]
fn main() {
	let input = INPUT_TEXT.to_string();

	// split input into blocks of size 50 and iterate over it, calling csl::spawn with string as input

	let mut handles = Vec::new();
	for block in input.as_bytes().chunks(500) {
		let block = str::from_utf8(block).unwrap();
		let block = block.to_string();
		let handle = csl::spawn(
			"map_receiver_stub",
			Some((block, ))
		);
		handles.push(handle);
	}

	let mut a_to_m = Vec::new();
	let mut n_to_z = Vec::new();

	for handle in handles {
		let mut output = csl::join::<Vec<String>>(handle).unwrap();
		output.sort();
		for string in output {
			if string.as_bytes()[0] < b'n' {
				a_to_m.push(string);
			} else {
				n_to_z.push(string);
			}
		}
	}

	let handle1 = csl::spawn(
		"reduce_receiver_stub",
		Some((a_to_m,))
	);

	let handle2 = csl::spawn(
		"reduce_receiver_stub",
		Some((n_to_z,))
	);

	let mut output_a_to_m = csl::join::<HashMap<String, u32>>(handle1).unwrap();
	let mut output_n_to_z = csl::join::<HashMap<String, u32>>(handle2).unwrap();

	//combine outputs above
	for (key, value) in output_n_to_z.drain() {
		if output_a_to_m.contains_key(&key) {
			*output_a_to_m.get_mut(&key).unwrap() += value;
		} else {
			output_a_to_m.insert(key, value);
		}
	}

	//print output
	for (key, value) in output_a_to_m.iter() {
		csl::print(&format!("{}: {}", key, value));
	}
}


/// Stub function to invoke `word_count`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
#[no_mangle]
#[csl::atom(name = "word_count_map")]
pub extern "C" fn map_receiver_stub(index: i32, len: i32) -> i32 {
	let args = csl::get_args::<(String,)>(index as u32, len as usize);

	let output = map(args.0);

	let ret_val_vec = to_allocvec(&output).unwrap();
	let ret_index = csl::put_ret_val(ret_val_vec);

	ret_index as i32
}

/// A developer-defined function that takes a String and "decorates" it
#[csl::atom(name = "word_count_map")]
fn map(input: String) -> Vec<String> {
	let mut mapper_vec: Vec<String> = vec![];
	for word in input.split_whitespace() {
		let word = word.to_lowercase();
		mapper_vec.push((format!("{word},1")));
	}
	mapper_vec
}


/// Stub function to invoke `word_count`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
#[no_mangle]
#[csl::atom(name = "word_count_reduce")]
pub extern "C" fn reduce_receiver_stub(index: i32, len: i32) -> i32 {
	let args = csl::get_args::<(Vec<String>,)>(index as u32, len as usize);

	let output = reduce(args.0);

	let ret_val_vec = to_allocvec(&output).unwrap();
	let ret_index = csl::put_ret_val(ret_val_vec);

	ret_index as i32
}

/// A developer-defined function that takes a String and "decorates" it
#[csl::atom(name = "word_count_reduce")]
fn reduce(input: Vec<String>) -> HashMap<String, u32> {
	// the input is a vector of strings, each string is a "word,count" pair
	// we need to split each string into a word and a count, and then add the counts
	// for each word
	let mut output: HashMap<String, u32> = HashMap::new();
	for string in input {
		let mut split = string.split(',');
		let word = split.next().unwrap().to_string();
		let count = split.next().unwrap().parse::<u32>().unwrap();
		if output.contains_key(&word) {
			*output.get_mut(&word).unwrap() += count;
		} else {
			output.insert(word, count);
		}
	}
	output
}

